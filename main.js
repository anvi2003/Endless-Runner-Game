import{Player} from './player.js';
import{InputHandler}from './input.js';
import {Background } from './background.js';
import {FlyingEnemy,ClimbingEnemy,GroundEnemy} from './enemies.js';
import {UI} from './UI.js';
window.addEventListener('load', function(){
 const canvas=document.getElementById('canvas1');
 const ctx=canvas.getContext('2d');
 canvas.width=1000;
 canvas.height=500;
 class Game{
    constructor(width,height){
        this.width=width;
        this.height=height;
        this.groundMargin=40;
        this.speed=0;
        this.maxSpeed=4;
        this.background=new Background(this);
        this.player=new Player(this);
        this.input=new InputHandler(this);
        this.UI=new UI(this);
        this.enemies=[]; // it'll hold all currently active enemies
        this.particles=[]; //holds all currently active particle objects
        this.collisions=[];
        this.enemyTimer=0;
        this.enemyInterval=1000;
        this.debug=false;
        this.score=0;
        this.winningScore=40;

        this.fontColor='black';
        this.time=0;
        this.maxTime=30000;
        this.gameOver=false;
        this.lives=30;
        this.player.currentState=this.player.states[0]; //it'll point to indees in the array // a player can only be in one state at a time
        this.player.currentState.enter(); 

        
    }
    update(deltaTime){
        this.time+=deltaTime;
        if(this.time> this.maxTime) this.gameOver=true;
        this.background.update();
        this.player.update(this.input.keys,deltaTime);
        //handleEnemies
        if(this.enemyTimer> this.enemyInterval){
            this.addEnemy();
            this.enemyTimer=0;
        }else{ 
            this.enemyTimer+=deltaTime;
        }
        this.enemies.forEach(enemy=>{
            enemy.update(deltaTime);
            if(enemy.markedForDeletion) this.enemies.splice(this.enemies.indexOf(enemy),1);
        });
        //handle particles

        this.particles.forEach((particle,index)=>{
            particle.update();
            if(particle.markedForDeletion) this.particles.splice(index,1);
        }); 
        //handle collision sprites
        this.collisions.forEach((collision,index)=>{
            collision.update(deltaTime);
            if(collision.markedForDeletion) this.collisions.splice(index,1);
        });
        
    }
    draw(context){
        this.background.draw(context);
        this.player.draw(context);
        this.enemies.forEach(enemy=>{
            enemy.draw(context);
        });
        this.particles.forEach(particle=>{
            particle.draw(context);
        });
        this.collisions.forEach(collision=>{
            collision.draw(context);
        });
        this.UI.draw(context);
    }
    addEnemy(){
        if(this.speed>0 && Math.random()<0.5) this.enemies.push(new GroundEnemy(this)); // Math.random() returns avalue between 0 and 1 // if it's less than 0.5 then return as per our condition // ground enemy will come in almost 50% of time , not full time , we reduced it's frequency to half in this way
        else if(this.speed>0) this.enemies.push(new ClimbingEnemy(this));
        this.enemies.push(new FlyingEnemy(this));
        
    }
}
const game=new Game(canvas.width, canvas.height);

let lastTime=0; // it will hold the value of timestamp from previous loop
function animate(timeStamp){
    const deltaTime=timeStamp-lastTime;
    //console.log(deltaTime);
    lastTime=timeStamp;
    ctx.clearRect(0,0, canvas.width,canvas.height);
    game.update(deltaTime);
    game.draw(ctx);
    if(!game.gameOver) requestAnimationFrame(animate);
}
animate(0); //for the very first animation , i have to pass value for timestamp , timestamp gets autogenerated only when request animation is called
});